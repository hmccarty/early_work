#include <thread>

#include <CameraServer.h>
#include <IterativeRobot.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/core/types.hpp>
#include "WPILib.h"
#include "math.h"

/**
 * This is a demo program showing the use of the RobotDrive class.
 * The SampleRobot class is the base of a robot application that will automatically call your
 * Autonomous and OperatorControl methods at the right time as controlled by the switches on
 * the driver station or the field controls.
 *
 * WARNING: While it may look like a good choice to use for your code if you're inexperienced,
 * don't. Unless you know what you are doing, complex code will be much more difficult under
 * this system. Use IterativeRobot or Command-Based instead if you're new.
 */
class Robot: public SampleRobot
{
	RobotDrive myRobot; // robot drive system
	Victor fl;
	Victor bl;
	Victor fr;
	Victor br;
	Joystick stick; // only joystick
	Joystick stick1;
	double sett = 0.01;
	cs::UsbCamera camera;
	cs::UsbCamera camera1;
	cs::UsbCamera changer = camera;
	cs::CvSink cvSink;
	cs::CvSource outputStreamStd;
	cv::Mat source;
	cv::Mat output;
	cv::Mat out;
	cv::Mat cvErodeSrc;
	cv::Mat cvErodeKernel;
	cv::Mat cvErodeOutput;
	cv::Mat contourimg;
	int firstgo = 0;
	double radianerror = 0;
	int camnum = 0;

public:
	Robot() :
			myRobot(10, 11),
			fl(15),
			bl(12),
			fr(13),
			br(14),// initialize the RobotDrive to use motor controllers on ports 0 and 1
			stick(0),
			stick1(1)
	{
		myRobot.SetExpiration(0.1);
	}

	/**
	 * Runs the motors with arcade steering.
	 */
	void OperatorControl()
	{
		while (IsOperatorControl() && IsEnabled())
		{
			Wait(0.005);				// wait for a motor update time
			myRobot.TankDrive(stick1.GetY(), stick.GetY());
			if (stick.GetRawButton(1)==true){
				if (radianerror < -.075)
				{
					myRobot.TankDrive(-0.5,0.0);
				}
				else if (radianerror > .075)
				{
					myRobot.TankDrive(0.0,-0.5);
				}
				else {
					myRobot.TankDrive(0.0,0.0);
				}
			}
			if (stick1.GetRawButton(2)==true) {
				if (changer == camera) {
					changer = camera1;
					cvSink = CameraServer::GetInstance()->GetVideo(camera1);
				}
				else {
					changer = camera;
					cvSink = CameraServer::GetInstance()->GetVideo(camera);
				}
			}
			CameraOnGo();
		}
	}
	void VisionThread()
	    {
			camera1 = CameraServer::GetInstance()->StartAutomaticCapture(1);
	        camera = CameraServer::GetInstance()->StartAutomaticCapture(0);
	        camera.SetResolution(640, 480);
	        cvSink = CameraServer::GetInstance()->GetVideo(camera);
	        outputStreamStd = CameraServer::GetInstance()->PutVideo("Vision", 640, 480);
	        cv::Point cvErodeAnchor(-1, -1);
	        cvErodeSrc = output;
	    }
	void CameraOnGo()
	{
		if (firstgo==0){
			VisionThread();
			firstgo=1;
		}
				std::vector<std::vector<cv::Point> > contours;
	            cvSink.GrabFrame(source);
	            cvtColor(source, output, cv::COLOR_BGR2HSV);
	            cv::inRange(output,cv::Scalar(60,160,170),cv::Scalar(90,255,255),out);
	            contourimg = source.clone();
	            cv::findContours(out, contours,CV_RETR_EXTERNAL,CV_CHAIN_APPROX_NONE, cv::Point(0,0));
	            SmartDashboard::PutNumber("contours",contours.size());
	            std::vector<cv::Moments>  mu(contours.size());
	            for(unsigned int idx = 0; idx<contours.size(); idx++)
	            {
	        	    cv::drawContours(contourimg,contours, idx,cv::Scalar(0,0,255),2,8);
	        	    mu[idx]=cv::moments(contours[idx],false);
	            }
	            float mc [contours.size()][1];
	            for(unsigned int idx = 0; idx<contours.size(); idx++)
				{
					mc[idx][0] = mu[idx].m10/mu[idx].m00/640;
					mc[idx][1] = mu[idx].m01/mu[idx].m00/480;
				}
	            SmartDashboard::PutNumber("x",mc[0][0]);
	            SmartDashboard::PutNumber("y",1-(mc[1][1]));
	            double x = mc[0][0];
	            double y = 1-(mc[1][1]);
	            //double theta = (-35.52*y)+103.766;
	            //double dx = (tan(theta)*180/3.14159265)*20.25;
	            //double distance = (166.76*(x*x))-(246.69*x)+97.904;
	            //SmartDashboard::PutNumber("distance",distance);
	            //double distanceV2 = 2.6266*pow(x,(-2.553));
	            //SmartDashboard::PutNumber("distanceV2",distanceV2);
	            double accaf = 4271.1*pow(y,4) - 11168*pow(y,3) + 10975*pow(y,2) - 4832.9*y + 816.6;
	            SmartDashboard::PutNumber("accaf",accaf);
	            radianerror = 0.9731*x - 0.5324;
	            SmartDashboard::PutNumber("radian error",radianerror);
	            outputStreamStd.PutFrame(contourimg);


	            	//double cvErodeIterations = 5.0;  // default Double
	                //int cvErodeBordertype = cv::BORDER_CONSTANT;
	            	//cv::Scalar cvErodeBordervalue(-1);
	            	//cv::erode(cvErodeSrc, cvErodeKernel, cvErodeAnchor, cvErodeIterations, cvErodeBordertype, cvErodeBordervalue, this->cvErodeOutput);


	    }

};

START_ROBOT_CLASS(Robot)
